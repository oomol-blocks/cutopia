{
  "version": 3,
  "sources": ["../main.ts", "../constants.ts"],
  "sourcesContent": ["// ================================= \u6D4B\u8BD5\u5F00\u59CB ===============================\nprocess.on('uncaughtException', (error) => {\n    console.error('\u672A\u6355\u83B7\u7684\u5F02\u5E38:', error);\n    console.error('\u5806\u6808\u8DDF\u8E2A:', error.stack);\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('\u672A\u5904\u7406\u7684 Promise \u62D2\u7EDD:', reason);\n    console.error('Promise:', promise);\n    process.exit(1);\n});\n\n// \u6DFB\u52A0\u542F\u52A8\u65E5\u5FD7\nconsole.log('\uD83D\uDE80 \u7A0B\u5E8F\u5F00\u59CB\u542F\u52A8...');\nconsole.log('Node.js \u7248\u672C:', process.version);\nconsole.log('\u5F53\u524D\u5DE5\u4F5C\u76EE\u5F55:', process.cwd());\n\ntry {\n    console.log('\uD83D\uDCE6 \u5F00\u59CB\u5BFC\u5165\u4F9D\u8D56...');\n    \n    // \u5206\u6B65\u5BFC\u5165\u6765\u786E\u5B9A\u54EA\u4E2A\u5305\u51FA\u95EE\u9898\n    console.log('\u5BFC\u5165 @ffmpeg-installer/ffmpeg...');\n    const { path } = await import('@ffmpeg-installer/ffmpeg');\n    console.log('\u2705 ffmpeg \u8DEF\u5F84:', path);\n    \n    // \u5982\u679C\u4F60\u6709\u5176\u4ED6\u5BFC\u5165\uFF0C\u4E5F\u5206\u6B65\u6DFB\u52A0\n    // console.log('\u5BFC\u5165\u5176\u4ED6\u5305...');\n    // const otherPackage = await import('other-package');\n    \n    console.log('\u2705 \u6240\u6709\u4F9D\u8D56\u5BFC\u5165\u6210\u529F');\n    \n    // \u4F60\u7684\u4E3B\u8981\u903B\u8F91\u4EE3\u7801...\n    console.log('\uD83C\uDFAF \u5F00\u59CB\u6267\u884C\u4E3B\u8981\u903B\u8F91...');\n    \n    // \u5728\u8FD9\u91CC\u6DFB\u52A0\u4F60\u7684\u5B9E\u9645\u4EE3\u7801\n    \n    console.log('\u2705 \u7A0B\u5E8F\u6267\u884C\u5B8C\u6210');\n    \n} catch (error) {\n    console.error('\u274C \u7A0B\u5E8F\u6267\u884C\u51FA\u9519:');\n    console.error('\u9519\u8BEF\u4FE1\u606F:', error.message);\n    console.error('\u9519\u8BEF\u7C7B\u578B:', error.constructor.name);\n    console.error('\u5806\u6808\u8DDF\u8E2A:', error.stack);\n    process.exit(1);\n}\n\n// ================================= \u6D4B\u8BD5\u7ED3\u675F ===============================\n\n\nimport type { Context } from \"@oomol/types/oocana\";\nimport { spawn } from \"child_process\";\nimport { path as ffmpegPath } from \"@ffmpeg-installer/ffmpeg\";\nimport path from \"path\"\nimport * as fs from 'node:fs/promises';\n\nimport { FORMAT_CONFIGS, ConversionOptions, VIDEO_FORMATS, BYTES_PER_GB, BYTES_PER_MB, QUALITY_THRESHOLDS } from \"./constants\"\nimport { VideoFormatOption } from \"./inputRender\"\n\ntype Outputs = {\n    output: String\n}\n\ntype Inputs = {\n    mediaPath: string | null;\n    isCompress: boolean;\n    mediaInfo: { format_name: string; audioChannels: string; codeRate: string; codecs: string; colorProfile: string; duration: string; name: string; kind: string; size: string; quality: string; dimensions: string };\n    [key: string]: any;\n}\n\ntype MediaInfo = Inputs[\"mediaInfo\"];\n\nexport default async function (\n    params: Inputs,\n    context: Context<Inputs, Outputs>\n): Promise<Partial<Outputs> | undefined | void> {\n    try {\n        const options: ConversionOptions = {\n            customQuality: params.customQuality,\n            customBitrate: params.customBitrate,\n            preserveMetadata: params.preserveMetadata,\n            hardwareAcceleration: params.hardwareAcceleration,\n            preset: params.preset\n        };\n\n        console.log('lalal', options)\n\n        const converter = new VideoConverter(context, options);\n        return await converter.convert(params);\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n\n        context.preview({\n            type: \"table\",\n            data: {\n                columns: [\"Error\", \"Details\"],\n                rows: [\n                    [\"\u274C Conversion Failed\", errorMessage],\n                    [\"File\", params.mediaPath || 'Unknown'],\n                    [\"Target Format\", params.targetFormat?.value || 'Unknown']\n                ]\n            }\n        });\n\n        throw new ConversionError(`Video conversion failed: ${errorMessage}`, error instanceof Error ? error : undefined);\n    }\n};\n\nclass VideoConverter {\n    private readonly context: Context<Inputs, Outputs>;\n    private readonly options: ConversionOptions;\n\n    constructor(context: Context<Inputs, Outputs>, options: ConversionOptions = {}) {\n        this.context = context;\n        this.options = {\n            preserveMetadata: true,\n            hardwareAcceleration: false,\n            preset: 'medium',\n            ...options\n        };\n    }\n\n    private static validateInputs(params: Inputs): void {\n        const { mediaPath, mediaInfo, targetFormat } = params;\n\n        if (!mediaPath) {\n            throw new Error(\"Media path is required\");\n        }\n\n        if (!mediaInfo || !mediaInfo.dimensions) {\n            throw new Error(\"Media info with dimensions is required\");\n        }\n\n        if (!targetFormat || !targetFormat.value) {\n            throw new Error(\"Target format is required\");\n        }\n\n        const supportedFormat = VIDEO_FORMATS.includes(targetFormat.value as any);\n        if (!supportedFormat) {\n            throw new Error(`Unsupported target format: ${targetFormat.value}`);\n        }\n    }\n\n    private static parseDimensions(dimensions: string): { width: number; height: number } {\n        const [width, height] = dimensions.split('x').map(Number);\n        if (isNaN(width) || isNaN(height)) {\n            throw new Error(`Invalid dimensions format: ${dimensions}`);\n        }\n        return { width, height };\n    }\n\n    private static formatFileSize(bytes: number): string {\n        if (bytes >= BYTES_PER_GB) {\n            return `${(bytes / BYTES_PER_GB).toFixed(2)} GB`;\n        }\n        return `${(bytes / BYTES_PER_MB).toFixed(2)} MB`;\n    }\n\n    private static async getFileSize(filePath: string): Promise<number> {\n        try {\n            const stats = await fs.stat(filePath);\n            return stats.size;\n        } catch {\n            return 0;\n        }\n    }\n\n    private static async pathExists(path: string) {\n        try {\n            await fs.stat(path);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    private static generateOutputPath(inputPath: string, targetFormat: string): string {\n        const inputExt = path.extname(inputPath);\n        const basePath = inputPath.replace(inputExt, '');\n\n        let outputPath = `${basePath}.${targetFormat}`;\n        let counter = 1;\n\n        while (VideoConverter.pathExists(outputPath)) {\n            outputPath = `${basePath}_${counter}.${targetFormat}`;\n            counter++;\n        }\n\n        return outputPath;\n    }\n\n    private getQualityPreset(quality: string): { crf: number; targetWidth?: number; targetHeight?: number } {\n        const { UHD, QHD, FHD, HD } = QUALITY_THRESHOLDS;\n\n        if (quality.includes('4K')) {\n            return { crf: 28, targetWidth: 1920, targetHeight: 1080 };\n        }\n\n        if (quality.includes('2K')) {\n            return { crf: 26, targetWidth: 1920, targetHeight: 1080 };\n        }\n\n        if (quality.includes('1080p')) {\n            return { crf: 28 };\n        }\n\n        if (quality.includes('720p')) {\n            return { crf: 24 };\n        }\n\n        return { crf: 24 };\n    }\n\n    private buildFFmpegArgs(params: Inputs, outputPath: string): string[] {\n        const { mediaPath, mediaInfo, targetFormat, isCompress } = params;\n        const args: string[] = ['-i', mediaPath!];\n\n        // Hardware acceleration support\n        if (this.options.hardwareAcceleration) {\n            args.unshift('-hwaccel', 'auto');\n        }\n\n        // Get format configuration\n        const formatConfig = FORMAT_CONFIGS[targetFormat.value.toLowerCase() as keyof typeof FORMAT_CONFIGS];\n        if (!formatConfig) {\n            throw new Error(`Unsupported format: ${targetFormat.value}`);\n        }\n\n        // Set codecs\n        args.push('-c:v', formatConfig.video, '-c:a', formatConfig.audio);\n\n        // Compression and quality settings\n        if (isCompress) {\n            const { width, height } = VideoConverter.parseDimensions(mediaInfo.dimensions);\n            const qualityPreset = this.getQualityPreset(mediaInfo.quality);\n\n            // Scaling settings\n            if (qualityPreset.targetWidth && qualityPreset.targetHeight) {\n                if (width > qualityPreset.targetWidth || height > qualityPreset.targetHeight) {\n                    args.push('-vf',\n                        `scale=${qualityPreset.targetWidth}:${qualityPreset.targetHeight}:force_original_aspect_ratio=decrease:force_divisible_by=2`\n                    );\n                }\n            }\n\n            // CRF quality setting\n            const crf = this.options.customQuality || qualityPreset.crf;\n            args.push('-crf', crf.toString());\n\n            // Audio bitrate\n            const audioBitrate = this.options.customBitrate || '128k';\n            args.push('-b:a', audioBitrate);\n        } else {\n            // High quality setting\n            const crf = this.options.customQuality || 18;\n            args.push('-crf', crf.toString());\n        }\n\n        // Preset setting\n        args.push('-preset', this.options.preset!);\n\n        // Metadata handling\n        if (this.options.preserveMetadata) {\n            args.push('-map_metadata', '0');\n        } else {\n            args.push('-map_metadata', '-1');\n        }\n\n        // Optimization settings\n        args.push(\n            '-movflags', '+faststart',  // Optimize for streaming\n            '-pix_fmt', 'yuv420p'      // Ensure compatibility\n        );\n\n        // Output file\n        args.push('-y', outputPath);\n\n        return args;\n    }\n\n    /**\n     * Execute FFmpeg conversion\n     */\n    private executeFFmpeg(args: string[]): Promise<{ stdout: string; stderr: string }> {\n        return new Promise((resolve, reject) => {\n            const ffmpeg = spawn(ffmpegPath, args);\n\n            let stdout = '';\n            let stderr = '';\n\n            ffmpeg.stdout.on('data', (data) => {\n                stdout += data.toString();\n            });\n\n            ffmpeg.stderr.on('data', (data) => {\n                stderr += data.toString();\n                // Can parse progress info here\n                this.parseProgress(data.toString());\n            });\n\n            ffmpeg.on('close', (code) => {\n                if (code === 0) {\n                    resolve({ stdout, stderr });\n                } else {\n                    reject(new Error(`FFmpeg failed with exit code ${code}\\nError: ${stderr}`));\n                }\n            });\n\n            ffmpeg.on('error', (error) => {\n                reject(new Error(`FFmpeg process error: ${error.message}`));\n            });\n        });\n    }\n\n    /**\n     * Parse progress information\n     */\n    private parseProgress(data: string): void {\n        const timeMatch = data.match(/time=(\\d+:\\d+:\\d+\\.\\d+)/);\n        if (timeMatch) {\n            this.context.reportProgress((parseInt(timeMatch[1], 10) / 100) * 100);\n        }\n    }\n\n    /**\n     * Create preview of the current task\n     */\n    private createPreview(\n        mediaInfo: MediaInfo,\n        targetFormat: VideoFormatOption,\n        originalSize: number,\n        outputSize: number,\n        compressionRatio: number,\n        conversionTime: number,\n        isCompress: boolean\n    ): void {\n        const compressionInfo = isCompress && compressionRatio > 0\n            ? ` (compressed ${compressionRatio.toFixed(1)}%)`\n            : '';\n\n        const previewRows = [\n            [\"Status\", \"\u2705 Conversion Successful\"],\n            [\"Original File\", `${mediaInfo.name} (${mediaInfo.kind.toUpperCase()})`],\n            [\"Target Format\", targetFormat.value.toUpperCase()],\n            [\"Original Size\", VideoConverter.formatFileSize(originalSize)],\n            [\"Output Size\", VideoConverter.formatFileSize(outputSize) + compressionInfo],\n            [\"Conversion Time\", `${(conversionTime / 1000).toFixed(1)}s`],\n            ...(compressionRatio > 0 ? [[\"Compression Ratio\", `${compressionRatio.toFixed(1)}%`]] : []),\n            [\"Quality\", mediaInfo.quality],\n            [\"Dimensions\", mediaInfo.dimensions]\n        ];\n\n        this.context.preview({\n            type: \"table\",\n            data: {\n                columns: [\"Property\", \"Value\"],\n                rows: previewRows\n            }\n        });\n    }\n\n    /**\n     * Execute video conversion\n     */\n    async convert(params: Inputs): Promise<Partial<Outputs>> {\n        // Validate parameters\n        // VideoConverter.validateInputs(params);\n\n        const { mediaPath, mediaInfo, targetFormat, isCompress } = params;\n\n        console.log(mediaInfo, mediaPath, targetFormat, isCompress)\n\n        // // Generate output path\n        // const outputPath = VideoConverter.generateOutputPath(mediaPath!, targetFormat.value);\n\n        // // Get original file size\n        // const originalSize = await VideoConverter.getFileSize(mediaPath!);\n\n        // // Build FFmpeg arguments\n        // const ffmpegArgs = this.buildFFmpegArgs(params, outputPath);\n\n        // // Record start time\n        // const startTime = Date.now();\n\n        // // Execute conversion\n        // await this.executeFFmpeg(ffmpegArgs);\n\n        // Calculate conversion time\n        // const conversionTime = Date.now() - startTime;\n\n        // Get output file size\n        // const outputSize = await VideoConverter.getFileSize(outputPath);\n        // const compressionRatio = originalSize > 0 ? ((originalSize - outputSize) / originalSize * 100) : 0;\n\n        // Create preview\n        // this.createPreview(\n        //     mediaInfo,\n        //     targetFormat,\n        //     originalSize,\n        //     outputSize,\n        //     compressionRatio,\n        //     conversionTime,\n        //     isCompress\n        // );\n\n        return {\n            output: \"outputPath\",\n            // originalSize,\n            // outputSize,\n            // compressionRatio: Math.round(compressionRatio * 100) / 100,\n            // conversionTime\n        };\n    }\n}\n\nclass ConversionError extends Error {\n    constructor(message: string, public readonly cause?: Error) {\n        super(message);\n        this.name = 'ConversionError';\n    }\n}\n", "export const VIDEO_FORMATS = [\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', \n    '.flv', '.webm',\n] as const;\n\nexport const FORMAT_CONFIGS = {\n    mp4: { video: 'libx264', audio: 'aac', container: 'mp4' },\n    avi: { video: 'libx264', audio: 'mp3', container: 'avi' },\n    mkv: { video: 'libx264', audio: 'aac', container: 'matroska' },\n    mov: { video: 'libx264', audio: 'aac', container: 'mov' },\n    wmv: { video: 'wmv2', audio: 'wmav2', container: 'asf' },\n    webm: { video: 'libvpx-vp9', audio: 'libopus', container: 'webm' },\n    flv: { video: 'libx264', audio: 'aac', container: 'flv' }\n} as const;\n\nexport const HARDWARE_ACCELERATION = {\n    nvidia: { decoder: 'h264_cuvid', encoder: 'h264_nvenc' },\n    intel: { decoder: 'h264_qsv', encoder: 'h264_qsv' },\n    amd: { decoder: 'h264_amf', encoder: 'h264_amf' }\n} as const;\n\nexport const BYTES_PER_GB = 1_000_000_000;\nexport const BYTES_PER_MB = 1_000_000;\nexport const KBPS_PER_MBPS = 1000;\n\nexport const QUALITY_THRESHOLDS = {\n    UHD: { width: 3840, height: 2160, bitrate: 15, highBitrate: 10 },\n    QHD: { width: 2560, height: 1440, bitrate: 8 },\n    FHD: { width: 1920, height: 1080, bitrate: 5, mediumBitrate: 2 },\n    HD: { width: 1280, height: 720, bitrate: 2 }\n} as const;\n\nexport const COLOR_MAPPINGS = {\n    bt709: '1',\n    bt2020: '9',\n    smpte170m: '6',\n    bt470bg: '5'\n} as const;\n\nexport const CODEC_MAPPINGS = {\n    video: {\n        h264: 'H.264',\n        hevc: 'H.265',\n        h265: 'H.265',\n        vp9: 'VP9',\n        vp8: 'VP8',\n        av1: 'AV1'\n    },\n    audio: {\n        aac: 'MPEG-4 AAC',\n        mp3: 'MPEG-1 Layer 3',\n        ac3: 'Dolby Digital',\n        opus: 'Opus',\n        vorbis: 'Vorbis'\n    }\n} as const;\n\nexport interface ConversionOptions {\n    customQuality?: number; // CRF\u503C\uFF0C0-51\u8303\u56F4\n    customBitrate?: string; // \u81EA\u5B9A\u4E49\u97F3\u9891\u6BD4\u7279\u7387\n    preserveMetadata?: boolean; // \u662F\u5426\u4FDD\u7559\u5143\u6570\u636E\n    hardwareAcceleration?: boolean; // \u662F\u5426\u4F7F\u7528\u786C\u4EF6\u52A0\u901F\n    preset?: 'ultrafast' | 'superfast' | 'veryfast' | 'faster' | 'fast' | 'medium' | 'slow' | 'slower' | 'veryslow';\n}\n"],
  "mappings": "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",
  "names": ["path", "path"]
}
