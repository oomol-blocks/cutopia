{
  "version": 3,
  "sources": ["../converter.ts", "../constants.ts", "../main.ts"],
  "sourcesContent": ["import type { Context } from \"@oomol/types/oocana\";\nimport { spawn } from \"child_process\";\nimport { path as ffmpegPath } from \"@ffmpeg-installer/ffmpeg\";\nimport path from \"path\"\nimport * as fs from 'node:fs/promises';\n\nimport { FORMAT_CONFIGS, ConversionOptions, VIDEO_FORMATS, BYTES_PER_GB, BYTES_PER_MB, QUALITY_THRESHOLDS } from \"./constants\"\nimport { VideoFormatOption } from \"./inputRender\"\nimport { Outputs, Inputs } from \"./main\"\n\ntype MediaInfo = Inputs[\"mediaInfo\"];\n\nexport class VideoConverter {\n    private readonly context: Context<Inputs, Outputs>;\n    private readonly options: ConversionOptions;\n    private totalDuration: number = 0;\n\n    constructor(context: Context<Inputs, Outputs>, options: ConversionOptions = {}) {\n        this.context = context;\n        this.options = {\n            preserveMetadata: true,\n            hardwareAcceleration: 'auto',\n            preset: 'fast',\n            copyStreams: true,\n            threads: 0,\n            ...options\n        };\n    }\n\n    private static validateInputs(params: Inputs): void {\n        const { mediaPath, mediaInfo, targetFormat } = params;\n\n        if (!mediaPath) {\n            throw new Error(\"Media path is required\");\n        }\n\n        if (!mediaInfo || !mediaInfo.dimensions) {\n            throw new Error(\"Media info with dimensions is required\");\n        }\n\n        if (!targetFormat || !targetFormat.value) {\n            throw new Error(\"Target format is required\");\n        }\n\n        const supportedFormat = VIDEO_FORMATS.includes(targetFormat.value as any);\n        if (!supportedFormat) {\n            throw new Error(`Unsupported target format: ${targetFormat.value}`);\n        }\n    }\n\n    private static parseDimensions(dimensions: string): { width: number; height: number } {\n        const [width, height] = dimensions.split('x').map(Number);\n        if (isNaN(width) || isNaN(height)) {\n            throw new Error(`Invalid dimensions format: ${dimensions}`);\n        }\n        return { width, height };\n    }\n\n    private static formatFileSize(bytes: number): string {\n        if (bytes >= BYTES_PER_GB) {\n            return `${(bytes / BYTES_PER_GB).toFixed(2)} GB`;\n        }\n        return `${(bytes / BYTES_PER_MB).toFixed(2)} MB`;\n    }\n\n    private static async getFileSize(filePath: string): Promise<number> {\n        try {\n            const stats = await fs.stat(filePath);\n            return stats.size;\n        } catch {\n            return 0;\n        }\n    }\n\n    private static generateOutputPath(inputPath: string, targetFormat: string): string {\n        return `${inputPath.replace(path.extname(inputPath), '')}-${Date.now()}${targetFormat}`;\n    }\n\n    private getQualityPreset(quality: string): { crf: number; targetWidth?: number; targetHeight?: number } {\n        const { UHD, QHD, FHD, HD } = QUALITY_THRESHOLDS;\n\n        if (quality.includes('4K')) {\n            return { crf: 28, targetWidth: 1920, targetHeight: 1080 };\n        }\n\n        if (quality.includes('2K')) {\n            return { crf: 26, targetWidth: 1920, targetHeight: 1080 };\n        }\n\n        if (quality.includes('1080p')) {\n            return { crf: 28 };\n        }\n\n        if (quality.includes('720p')) {\n            return { crf: 24 };\n        }\n\n        return { crf: 24 };\n    }\n\n    private canCopyStreams(inputFormat: string, outputFormat: string): boolean {\n        const compatibleFormats = ['.mp4', '.mov'];\n        return compatibleFormats.includes(inputFormat) && \n               compatibleFormats.includes(outputFormat);\n    }\n\n    private buildFFmpegArgs(params: Inputs, outputPath: string): string[] {\n        const { mediaPath, mediaInfo, targetFormat, isCompress } = params;\n        const args: string[] = [];\n\n        // 1. \u8F93\u5165\u4F18\u5316\n        args.push(\n            '-fflags', '+fastseek+genpts',\n            '-probesize', '32M',\n            '-analyzeduration', '10M'\n        );\n\n        // 2. \u786C\u4EF6\u52A0\u901F\u8BBE\u7F6E\uFF08\u5728\u8F93\u5165\u4E4B\u524D\uFF09\n        // if (this.options.hardwareAcceleration && Boolean(this.options.hardwareAcceleration) !== false) {\n        //     if (this.options.hardwareAcceleration === 'nvidia') {\n        //         args.push('-hwaccel', 'cuda', '-hwaccel_output_format', 'cuda');\n        //     } else if (this.options.hardwareAcceleration === 'intel') {\n        //         args.push('-hwaccel', 'qsv');\n        //     } else {\n        //         args.push('-hwaccel', 'auto');\n        //     }\n        // }\n\n        args.push('-i', mediaPath!);\n\n        const kind = targetFormat.value.substring(1);\n        const formatConfig = FORMAT_CONFIGS[kind.toLowerCase() as keyof typeof FORMAT_CONFIGS];\n        \n        if (!formatConfig) {\n            throw new Error(`Unsupported format: ${targetFormat.value}`);\n        }\n\n        // 3. \u68C0\u67E5\u662F\u5426\u53EF\u4EE5\u76F4\u63A5\u590D\u5236\u6D41\uFF08\u6700\u5FEB\uFF09\n        if (this.options.copyStreams && !isCompress && \n            this.canCopyStreams(path.extname(mediaPath!), targetFormat.value)) {\n            console.log(\"\uD83D\uDE80 \u4F7F\u7528\u6D41\u590D\u5236\u6A21\u5F0F\uFF0C\u901F\u5EA6\u6700\u5FEB\");\n            args.push('-c', 'copy');\n        } else {\n            // 4. \u9009\u62E9\u7F16\u7801\u5668\uFF08\u786C\u4EF6\u4F18\u5148\uFF09\n            let videoCodec = formatConfig.video;\n            \n            // if (this.options.hardwareAcceleration && Boolean(this.options.hardwareAcceleration) !== false) {\n            //     if (this.options.hardwareAcceleration === 'nvidia' && formatConfig.videoHW) {\n            //         videoCodec = formatConfig.videoHW;\n            //         console.log(\"\uD83D\uDE80 \u4F7F\u7528NVIDIA\u786C\u4EF6\u52A0\u901F\");\n            //     } else if (this.options.hardwareAcceleration === 'intel' && formatConfig.videoQSV) {\n            //         videoCodec = formatConfig.videoQSV;\n            //         console.log(\"\uD83D\uDE80 \u4F7F\u7528Intel\u786C\u4EF6\u52A0\u901F\");\n            //     } else if (formatConfig.videoHW) {\n            //         videoCodec = formatConfig.videoHW; // \u9ED8\u8BA4\u5C1D\u8BD5NVIDIA\n            //         console.log(\"\uD83D\uDE80 \u5C1D\u8BD5\u4F7F\u7528\u786C\u4EF6\u52A0\u901F\");\n            //     }\n            // }\n\n            args.push('-c:v', videoCodec);\n\n            // 5. \u97F3\u9891\u5904\u7406\uFF08\u4F18\u5148\u590D\u5236\uFF09\n            if (!isCompress) {\n                args.push('-c:a', 'copy'); // \u4E0D\u538B\u7F29\u65F6\u76F4\u63A5\u590D\u5236\u97F3\u9891\n            } else {\n                args.push('-c:a', formatConfig.audio);\n            }\n\n            // 6. \u8D28\u91CF\u548C\u538B\u7F29\u8BBE\u7F6E\n            if (isCompress) {\n                const { width, height } = VideoConverter.parseDimensions(mediaInfo.dimensions);\n                const qualityPreset = this.getQualityPreset(mediaInfo.quality);\n\n                // \u7F29\u653E\u8BBE\u7F6E\n                if (qualityPreset.targetWidth && qualityPreset.targetHeight) {\n                    if (width > qualityPreset.targetWidth || height > qualityPreset.targetHeight) {\n                        args.push('-vf',\n                            `scale=${qualityPreset.targetWidth}:${qualityPreset.targetHeight}:force_original_aspect_ratio=decrease:force_divisible_by=2`\n                        );\n                    }\n                }\n\n                // \u8D28\u91CF\u8BBE\u7F6E\uFF08\u786C\u4EF6\u7F16\u7801\u5668\u4F7F\u7528\u4E0D\u540C\u53C2\u6570\uFF09\n                const crf = this.options.customQuality || qualityPreset.crf;\n                if (videoCodec.includes('nvenc')) {\n                    args.push('-crf', crf.toString()); // \u66F4\u65B0\u5230\u6700\u884C\u7248---NVIDIA\u4F7F\u7528CQ\n                } else if (videoCodec.includes('qsv')) {\n                    args.push('-q', crf.toString()); // Intel QSV\u4F7F\u7528q\n                } else {\n                    args.push('-crf', crf.toString()); // \u8F6F\u4EF6\u7F16\u7801\u4F7F\u7528CRF\n                }\n\n                // \u97F3\u9891\u6BD4\u7279\u7387\n                if (!args.includes('-c:a') || !args[args.indexOf('-c:a') + 1].includes('copy')) {\n                    const audioBitrate = this.options.customBitrate || '128k';\n                    args.push('-b:a', audioBitrate);\n                }\n            } else {\n                // \u9AD8\u8D28\u91CF\u8BBE\u7F6E\n                const crf = this.options.customQuality || 18;\n                if (videoCodec.includes('nvenc')) {\n                    args.push('-crf', crf.toString());\n                } else if (videoCodec.includes('qsv')) {\n                    args.push('-q', crf.toString());\n                } else {\n                    args.push('-crf', crf.toString());\n                }\n            }\n\n            // 7. \u9884\u8BBE\u8BBE\u7F6E\uFF08\u786C\u4EF6\u7F16\u7801\u5668\u4F7F\u7528\u4E0D\u540C\u9884\u8BBE\uFF09\n        //     if (videoCodec.includes('nvenc')) {\n        //         args.push('-preset', 'fast'); // NVIDIA\u9884\u8BBE\n        //     } else if (videoCodec.includes('qsv')) {\n        //         args.push('-preset', 'fast'); // Intel\u9884\u8BBE\n        //     } else {\n        //         args.push('-preset', this.options.preset!); // \u8F6F\u4EF6\u7F16\u7801\u9884\u8BBE\n        //     }\n        }\n\n        // 8. \u7EBF\u7A0B\u4F18\u5316\n        if (this.options.threads !== undefined) {\n            args.push('-threads', this.options.threads.toString());\n        }\n\n        // 9. \u5143\u6570\u636E\u5904\u7406\n        if (this.options.preserveMetadata) {\n            args.push('-map_metadata', '0');\n        } else {\n            args.push('-map_metadata', '-1');\n        }\n\n        // 10. \u8F93\u51FA\u4F18\u5316\n        args.push(\n            '-movflags', '+faststart', // \u4F18\u5316streaming\n            '-pix_fmt', 'yuv420p',     // \u517C\u5BB9\u6027\n            '-y', outputPath            // \u8986\u76D6\u8F93\u51FA\u6587\u4EF6\n        );\n\n        console.log(\"\uD83D\uDD27 FFmpeg\u53C2\u6570:\", args.join(' '));\n        return args;\n    }\n\n    private parseDurationFromFFmpegOutput(data: string): void {\n        if (this.totalDuration <= 0) {\n            const durationMatch = data.match(/Duration:\\s*(\\d+):(\\d+):(\\d+\\.\\d+)/);\n            if (durationMatch) {\n                const hours = parseInt(durationMatch[1], 10);\n                const minutes = parseInt(durationMatch[2], 10);\n                const seconds = parseFloat(durationMatch[3]);\n                \n                this.totalDuration = hours * 3600 + minutes * 60 + seconds;\n                console.log(`\uD83D\uDCCF \u4ECEFFmpeg\u8F93\u51FA\u89E3\u6790\u5230\u89C6\u9891\u65F6\u957F: ${this.totalDuration.toFixed(2)}\u79D2`);\n            }\n        }\n    }\n\n    /**\n     * Execute FFmpeg conversion\n     */\n    private executeFFmpeg(args: string[]): Promise<{ stdout: string; stderr: string }> {\n        return new Promise((resolve, reject) => {\n            const ffmpeg = spawn(ffmpegPath, args);\n\n            let stdout = '';\n            let stderr = '';\n\n            ffmpeg.stdout.on('data', (data) => {\n                stdout += data.toString();\n            });\n\n            ffmpeg.stderr.on('data', (data) => {\n                const dataStr = data.toString();\n                stderr += dataStr;\n                this.parseDurationFromFFmpegOutput(dataStr);\n                this.parseProgress(dataStr);\n            });\n\n            ffmpeg.on('close', (code) => {\n                if (code === 0) {\n                    resolve({ stdout, stderr });\n                } else {\n                    reject(new Error(`FFmpeg failed with exit code ${code}\\nError: ${stderr}`));\n                }\n            });\n\n            ffmpeg.on('error', (error) => {\n                reject(new Error(`FFmpeg process error: ${error.message}`));\n            });\n        });\n    }\n\n    /**\n     * Parse progress information\n     */\n    private parseProgress(data: string): void {\n        const timeMatch = data.match(/time=(\\d+):(\\d+):(\\d+\\.\\d+)/);\n        if (timeMatch && this.totalDuration > 0) {\n            const hours = parseInt(timeMatch[1], 10);\n            const minutes = parseInt(timeMatch[2], 10);\n            const seconds = parseFloat(timeMatch[3]);\n\n            const currentTimeInSeconds = hours * 3600 + minutes * 60 + seconds;\n            const progress = Math.min((currentTimeInSeconds / this.totalDuration) * 100, 100);\n\n            this.context.reportProgress(progress);\n        }\n    }\n\n    /**\n     * Create preview of the current task\n     */\n    private createPreview(\n        mediaInfo: MediaInfo,\n        targetFormat: VideoFormatOption,\n        originalSize: number,\n        outputSize: number,\n        compressionRatio: number,\n        conversionTime: number,\n        isCompress: boolean\n    ): void {\n        const compressionInfo = isCompress && compressionRatio > 0\n            ? ` (compressed ${compressionRatio.toFixed(1)}%)`\n            : '';\n\n        const previewRows = [\n            [\"Status\", \"\u2705 Conversion Successful\"],\n            [\"Original File\", `${mediaInfo.name} (${mediaInfo.kind.toUpperCase()})`],\n            [\"Target Format\", targetFormat.value.toLowerCase()],\n            [\"Original Size\", VideoConverter.formatFileSize(originalSize)],\n            [\"Output Size\", VideoConverter.formatFileSize(outputSize) + compressionInfo],\n            [\"Conversion Time\", `${(conversionTime / 1000).toFixed(1)}s`],\n            ...(compressionRatio > 0 ? [[\"Compression Ratio\", `${compressionRatio.toFixed(1)}%`]] : []),\n            [\"Quality\", mediaInfo.quality],\n            [\"Dimensions\", mediaInfo.dimensions]\n        ];\n\n        this.context.preview({\n            type: \"table\",\n            data: {\n                columns: [\"Property\", \"Value\"],\n                rows: previewRows\n            }\n        });\n    }\n\n    /**\n     * Execute video conversion\n     */\n    async convert(params) {\n        console.log(\"\uD83C\uDFAC \u5F00\u59CB\u89C6\u9891\u8F6C\u6362\u6D41\u7A0B...\");\n\n        // \u9A8C\u8BC1\u8F93\u5165\u53C2\u6570\n        console.log(\"\uD83D\uDCCB \u9A8C\u8BC1\u8F93\u5165\u53C2\u6570...\");\n        VideoConverter.validateInputs(params);\n        console.log(\"\u2705 \u53C2\u6570\u9A8C\u8BC1\u901A\u8FC7\");\n\n        const { mediaPath, mediaInfo, targetFormat, isCompress } = params;\n\n        console.log(\"\uD83D\uDCC2 \u8F93\u5165\u6587\u4EF6\u4FE1\u606F:\");\n        console.log(`   \u6587\u4EF6\u8DEF\u5F84: ${mediaPath}`);\n        console.log(`   \u6587\u4EF6\u540D: ${mediaInfo.name}`);\n        console.log(`   \u683C\u5F0F: ${mediaInfo.kind.toUpperCase()}`);\n        console.log(`   \u5206\u8FA8\u7387: ${mediaInfo.dimensions}`);\n        console.log(`   \u8D28\u91CF: ${mediaInfo.quality}`);\n        console.log(`   \u76EE\u6807\u683C\u5F0F: ${targetFormat.value.toUpperCase()}`);\n        console.log(`   \u538B\u7F29\u6A21\u5F0F: ${isCompress ? '\u662F' : '\u5426'}`);\n\n        // \u751F\u6210\u8F93\u51FA\u8DEF\u5F84\n        console.log(\"\uD83D\uDCC1 \u751F\u6210\u8F93\u51FA\u6587\u4EF6\u8DEF\u5F84...\");\n        const outputPath = VideoConverter.generateOutputPath(mediaPath, targetFormat.value);\n        console.log(`\u2705 \u8F93\u51FA\u8DEF\u5F84: ${outputPath}`);\n\n        // \u83B7\u53D6\u539F\u59CB\u6587\u4EF6\u5927\u5C0F\n        console.log(\"\uD83D\uDCCF \u83B7\u53D6\u539F\u59CB\u6587\u4EF6\u5927\u5C0F...\");\n        const originalSize = await VideoConverter.getFileSize(mediaPath);\n        console.log(`\u2705 \u539F\u59CB\u6587\u4EF6\u5927\u5C0F: ${VideoConverter.formatFileSize(originalSize)}`);\n\n        // \u6784\u5EFAFFmpeg\u53C2\u6570\n        console.log(\"\u2699\uFE0F \u6784\u5EFA\u8F6C\u6362\u53C2\u6570...\");\n        const ffmpegArgs = this.buildFFmpegArgs(params, outputPath);\n        console.log(\"\u2705 \u8F6C\u6362\u53C2\u6570\u6784\u5EFA\u5B8C\u6210\");\n\n        // \u5F00\u59CB\u8F6C\u6362\n        console.log(\"\uD83D\uDE80 \u5F00\u59CB\u6267\u884C\u89C6\u9891\u8F6C\u6362...\");\n        const startTime = Date.now();\n\n        try {\n            await this.executeFFmpeg(ffmpegArgs);\n            console.log(\"\u2705 \u89C6\u9891\u8F6C\u6362\u6210\u529F\u5B8C\u6210!\");\n        } catch (error) {\n            console.error(\"\u274C \u89C6\u9891\u8F6C\u6362\u5931\u8D25:\", error.message);\n            throw error;\n        }\n\n        // \u8BA1\u7B97\u8F6C\u6362\u65F6\u95F4\n        const conversionTime = Date.now() - startTime;\n        console.log(`\u23F1\uFE0F \u8F6C\u6362\u8017\u65F6: ${(conversionTime / 1000).toFixed(1)}\u79D2`);\n\n        // \u83B7\u53D6\u8F93\u51FA\u6587\u4EF6\u5927\u5C0F\n        console.log(\"\uD83D\uDCCA \u83B7\u53D6\u8F93\u51FA\u6587\u4EF6\u4FE1\u606F...\");\n        const outputSize = await VideoConverter.getFileSize(outputPath);\n        const compressionRatio = originalSize > 0 ? ((originalSize - outputSize) / originalSize * 100) : 0;\n\n        console.log(`\u2705 \u8F93\u51FA\u6587\u4EF6\u5927\u5C0F: ${VideoConverter.formatFileSize(outputSize)}`);\n        if (compressionRatio > 0) {\n            console.log(`\uD83D\uDCC9 \u538B\u7F29\u6BD4\u4F8B: ${compressionRatio.toFixed(1)}%`);\n        }\n\n        // \u521B\u5EFA\u9884\u89C8\n        console.log(\"\uD83D\uDCCB \u751F\u6210\u8F6C\u6362\u62A5\u544A...\");\n        this.createPreview(\n            mediaInfo,\n            targetFormat,\n            originalSize,\n            outputSize,\n            compressionRatio,\n            conversionTime,\n            isCompress\n        );\n        console.log(\"\u2705 \u8F6C\u6362\u62A5\u544A\u751F\u6210\u5B8C\u6210\");\n        console.log(\"\uD83C\uDF89 \u89C6\u9891\u8F6C\u6362\u6D41\u7A0B\u5168\u90E8\u5B8C\u6210!\");\n        return {\n            media: outputPath\n        };\n    }\n}\n\nexport class ConversionError extends Error {\n    constructor(message: string, public readonly cause?: Error) {\n        super(message);\n        this.name = 'ConversionError';\n    }\n}", "export const VIDEO_FORMATS = [\n    '.mp4', '.avi', '.mkv', '.mov', '.wmv', \n    '.flv', '.webm',\n] as const;\n\nexport const FORMAT_CONFIGS = {\n    mp4: { \n        video: 'libx264', \n        videoHW: 'h264_nvenc', // NVIDIA\u786C\u4EF6\u52A0\u901F\n        videoQSV: 'h264_qsv',  // Intel\u786C\u4EF6\u52A0\u901F\n        audio: 'aac', \n        container: 'mp4' \n    },\n    avi: { \n        video: 'libx264', \n        videoHW: 'h264_nvenc',\n        videoQSV: 'h264_qsv',\n        audio: 'mp3', \n        container: 'avi' \n    },\n    mkv: { \n        video: 'libx264', \n        videoHW: 'h264_nvenc',\n        videoQSV: 'h264_qsv',\n        audio: 'aac', \n        container: 'matroska' \n    },\n    mov: { \n        video: 'libx264', \n        videoHW: 'h264_nvenc',\n        videoQSV: 'h264_qsv',\n        audio: 'aac', \n        container: 'mov' \n    },\n    wmv: { video: 'wmv2', audio: 'wmav2', container: 'asf' },\n    webm: { video: 'libvpx-vp9', audio: 'libopus', container: 'webm' },\n    flv: { \n        video: 'libx264', \n        videoHW: 'h264_nvenc',\n        videoQSV: 'h264_qsv',\n        audio: 'aac', \n        container: 'flv' \n    }\n} as const;\n\nexport const HARDWARE_ACCELERATION = {\n    nvidia: { decoder: 'h264_cuvid', encoder: 'h264_nvenc' },\n    intel: { decoder: 'h264_qsv', encoder: 'h264_qsv' },\n    amd: { decoder: 'h264_amf', encoder: 'h264_amf' }\n} as const;\n\nexport const BYTES_PER_GB = 1_000_000_000;\nexport const BYTES_PER_MB = 1_000_000;\nexport const KBPS_PER_MBPS = 1000;\n\nexport const QUALITY_THRESHOLDS = {\n    UHD: { width: 3840, height: 2160, bitrate: 15, highBitrate: 10 },\n    QHD: { width: 2560, height: 1440, bitrate: 8 },\n    FHD: { width: 1920, height: 1080, bitrate: 5, mediumBitrate: 2 },\n    HD: { width: 1280, height: 720, bitrate: 2 }\n} as const;\n\nexport const COLOR_MAPPINGS = {\n    bt709: '1',\n    bt2020: '9',\n    smpte170m: '6',\n    bt470bg: '5'\n} as const;\n\nexport const CODEC_MAPPINGS = {\n    video: {\n        h264: 'H.264',\n        hevc: 'H.265',\n        h265: 'H.265',\n        vp9: 'VP9',\n        vp8: 'VP8',\n        av1: 'AV1'\n    },\n    audio: {\n        aac: 'MPEG-4 AAC',\n        mp3: 'MPEG-1 Layer 3',\n        ac3: 'Dolby Digital',\n        opus: 'Opus',\n        vorbis: 'Vorbis'\n    }\n} as const;\n\nexport interface ConversionOptions {\n    customQuality?: number;\n    customBitrate?: string;\n    preserveMetadata?: boolean;\n    hardwareAcceleration?: boolean | 'nvidia' | 'intel' | 'auto'; // \u6269\u5C55\u786C\u4EF6\u52A0\u901F\u9009\u9879\n    preset?: 'ultrafast' | 'superfast' | 'veryfast' | 'faster' | 'fast' | 'medium' | 'slow' | 'slower' | 'veryslow';\n    copyStreams?: boolean; // \u76F4\u63A5\u590D\u5236\u6D41\uFF0C\u6700\u5FEB\u7684\u8F6C\u6362\u65B9\u5F0F\n    threads?: number; // \u7EBF\u7A0B\u6570\n}\n", "import type { Context } from \"@oomol/types/oocana\";\n\n\nimport { ConversionOptions } from \"./constants\"\nimport { VideoConverter, ConversionError} from \"./converter\"\n\nexport type Outputs = {\n    media: string\n}\n\nexport type Inputs = {\n    mediaPath: string | null;\n    isCompress: boolean;\n    mediaInfo: { format_name: string; audioChannels: string; codeRate: string; codecs: string; colorProfile: string; duration: string; name: string; kind: string; size: string; quality: string; dimensions: string };\n    [key: string]: any;\n}\n\nexport default async function (\n    params: Inputs,\n    context: Context<Inputs, Outputs>\n): Promise<Partial<Outputs> | undefined | void> {\n    try {\n        const options: ConversionOptions = {\n            customQuality: params.customQuality,\n            customBitrate: params.customBitrate,\n            preserveMetadata: params.preserveMetadata || false,\n            hardwareAcceleration: params.hardwareAcceleration || 'auto',\n            preset: params.preset || \"fast\"\n        };\n\n        console.log('input: ', params.targetFormat)\n\n        const converter = new VideoConverter(context, options);\n        return await converter.convert(params);\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n\n        context.preview({\n            type: \"table\",\n            data: {\n                columns: [\"Error\", \"Details\"],\n                rows: [\n                    [\"\u274C Conversion Failed\", errorMessage],\n                    [\"File\", params.mediaPath || 'Unknown'],\n                    [\"Target Format\", params.targetFormat?.value || 'Unknown']\n                ]\n            }\n        });\n\n        throw new ConversionError(`Video conversion failed: ${errorMessage}`, error instanceof Error ? error : undefined);\n    }\n};\n"],
  "mappings": "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",
  "names": []
}
